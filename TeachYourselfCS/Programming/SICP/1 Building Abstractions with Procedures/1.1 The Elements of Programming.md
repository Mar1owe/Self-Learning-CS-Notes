**A Word Before the Chaper**  
The dialect of Lisp used in this book is *Scheme*. 
[Scheme Interpreter](https://inst.eecs.berkeley.edu/~cs61a/fa14/assets/interpreter/scheme.html)

Lisp has not overcome its old reputation as hopelessly inefficient, but it  is now used in many applications where efficiency is not the central concern. For example, operating-system shell languages and extension languages for editors and computer-aided design systems. 
# The Elements of Programming
Every powerful language has three mechanisms for combining simple ideas to form more complex ideas:
1. primitive expressions  
    which represent the simplest entities the language is concerned with,
2. means of combination  
    by which comound elements are built from simpler ones, and
3. means of abstraction  
    by which compound elements can be named and manipulated as units.

In programming, we deal with ***procedures*** and ***data***.
## Expressions
```
(+ 2 4)
6


(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
57


(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
57
```
combination: formed by delimiting a list of expressions within parentheses in order to denote procedure application  
operator: `+`  
operand(s): `2`, `4`  
*prefix* notation: the convention of placing the operator tot he left of the operands  
*pretty-printing*: in which each long combination is written so that the operands are aligned vertically and the structure get displayed clearly.
## Naming and the Environment
The name identifies a *variable* whose *value* is the object.  
In the Scheme dialect of Lisp, we name things with `Define`
```
(define size 2)
size
2

(* 5 size)
10

(define pi 3.14159)
(define radius 10)
(* pi (* radius radius))
314.159

(define circumference (* 2 pi radius))
circumference
62.8318
```
To associate values with symbols for later retrieving, the interpreter has some kind of memory called ***global environment***.
## Evaluating Combinations
The procedure of evaluating combinations:
1. Evaluate the subexpressions of the combination
2. Apply the procedure that is the value of the operator (the leftmost subexpression) to the operands (arguments that are the values of the other subexpressions)
```
(* (+ 2 (* 4 6)) (+ 3 5 7))
```
picture  
this is an example of *recursion* called *tree accumulation.*

Notice that the evaluation of `define` is an exception. We don’t apply `define` to two arguments. exceptions like this are called *special forms*. Each special form has its own evaluation rules.

## Compound Procedures

We have identified in Lisp some of the elements that must appear in any powerful programming language:

- Numbers and arithmetic operations are primitive data and procedures.
- Nesting of combinations provides a means of combining operations.
- Definitions that associate names with values provide a limited means of abstraction.

**About *procedure definitions***

The general form is
```
(define (<name> <formal parameters>) <body>)
```
```
(define (square x) (* x x))
(square 12)
144

(square (+ 2 5))
49
```
Compound procedures are used in exactly the same way as primitive procedures.
## The Substitution Model for Procedure Application
To apply a compound procedure to arguments, evaluate the body of the procedure with each formal parameter replaced by the corresponding argument.
```
(define (sum-of-squares x y)
  (+ (square x) (square y)))

(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))

(f 5)
(sum-of-squares (+ a 1) (* a 2))
(sum-of-squares (+ 5 1) (* 5 2))
(+ (square 6) (square 10))
(+ (* 6 6) (* 10 10))
(+ 36 100)
136
```
This is *applicative-order evaluation*. (which is the one that Lisp uses)  
The process is called the *substitution model* for procedure application.

**Applicative order versus normal order**  
Another evaluation model would **not** evaluate the operands until their values were needed. It would first substitute operand expressions for parameters until it obtained an expression involving only primitive operators, and would then perform the evaluation. 
```
(sum-of-squares (+ 5 1) (* 5 2))

(+ (square (+ 5 1)) 
   (square (* 5 2)))

(+ (* (+ 5 1) (+ 5 1)) 
   (* (* 5 2) (* 5 2)))

(+ (* 6 6) 
   (* 10 10))

(+ 36 100)

136
```
This is *normal-order evaluation*
## Conditional Expressions and Predicates
`cond` (stands for "conditional") is used in Lisp for notating *case analysis*
```
(cond (⟨p₁⟩ ⟨e₁⟩)
      (⟨p₂⟩ ⟨e₂⟩)
      …
      (⟨pₙ⟩ ⟨eₙ⟩))


(define (abs x)
  (cond ((> x 0) x)
        ((= x 0) 0)
        ((< x 0) (- x))))
```
*clause*: `(<p> <e>)`  
*predicate*: `<p>`, it produces either `true` or `false`  
*consequent expression*: `<e>`

Other ways of writing the absolute-value procedure:
```
(define (abs x)
  (cond ((< x 0) (- x))
        (else x)))


(define (abs x)
  (if (< x 0)
      (- x)
      x))
```

**Logical composition operations**
```
(if ⟨predicate⟩ ⟨consequent⟩ ⟨alternative⟩)
```
```
(and ⟨e₁⟩ … ⟨eₙ⟩)
```
```
(or ⟨e₁⟩ … ⟨eₙ⟩)
```
```
(not ⟨e⟩)
```
Notice that `and` and `or` are special forms, not procedures, because the subexpressions are not necessarily all evaluated. `Not` is an ordinary procedure. 