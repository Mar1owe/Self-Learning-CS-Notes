The dialect of Lisp used in this book is *Scheme*. 
[Scheme Interpreter](https://inst.eecs.berkeley.edu/~cs61a/fa14/assets/interpreter/scheme.html)
# The Elements of Programming
Every powerful language has three mechanisms for combining simple ideas to form more complex ideas:
1. primitive expressions  
    which represent the simplest entities the language is concerned with,
2. means of combination  
    by which comound elements are built from simpler ones, and
3. means of abstraction  
    by which compound elements can be named and manipulated as units.
In programming, we deal with ***procedures*** and ***data***.
## Expressions
combination: formed by delimiting a list of expressions within parentheses in order to denote procedure application  
operator, operand    
*prefix* notation: the convention of placing the operator tot he left of the operands  
*pretty-printing*: in which each long combination is written so that the operands are aligned vertically and the structure get displayed clearly.
## Naming and the Environment
The name identifies a *variable* whose *value* is the object.  
In the Scheme dialect of Lisp, we name things with `Define`
To associate values with symbols for later retrieving, the interpreter has some kind of memory called ***global environment***.
## Evaluating Combinations
The procedure of evaluating combinations:
1. Evaluate the subexpressions of the combination
2. Apply the procedure that is the value of the operator (the leftmost subexpression) to the operands (arguments that are the values of the other subexpressions)
```Lisp
(* (+ 2 (* 4 6)) (+ 3 5 7))
```
Notice that the evaluation of `define` is an exception. We don’t apply `define` to two arguments. exceptions like this are called *special forms*. Each special form has its own evaluation rules.
## Compound Procedures
**About *procedure definitions***
The general form is
```Lisp
(define (<name> <formal parameters>) <body>)
```
```Lisp
(define (square x) (* x x))
(square 12)
144

(square (+ 2 5))
49
```
Compound procedures are used in exactly the same way as primitive procedures.
## The Substitution Model for Procedure Application
To apply a compound procedure to arguments, evaluate the body of the procedure with each formal parameter replaced by the corresponding argument.
```Lisp
(define (sum-of-squares x y)
  (+ (square x) (square y)))

(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))

(f 5)
(sum-of-squares (+ a 1) (* a 2))
(sum-of-squares (+ 5 1) (* 5 2))
(+ (square 6) (square 10))
(+ (* 6 6) (* 10 10))
(+ 36 100)
136
```
This is *applicative-order evaluation*. (which is the one that Lisp uses)  
The process is called the *substitution model* for procedure application.
## Conditional Expressions and Predicates
`cond` (stands for "conditional") is used in Lisp for notating *case analysis*
```Lisp
(cond (⟨p₁⟩ ⟨e₁⟩)
      (⟨p₂⟩ ⟨e₂⟩)
      …
      (⟨pₙ⟩ ⟨eₙ⟩))


(define (abs x)
  (cond ((> x 0) x)
        ((= x 0) 0)
        ((< x 0) (- x))))
```
*clause*: `(<p> <e>)`  
*predicate*: `<p>`, it produces either `true` or `false`  
*consequent expression*: `<e>`
**Logical composition operations**
```
(if ⟨predicate⟩ ⟨consequent⟩ ⟨alternative⟩)
```
```
(and ⟨e₁⟩ … ⟨eₙ⟩)
```
```
(or ⟨e₁⟩ … ⟨eₙ⟩)
```
```
(not ⟨e⟩)
```
Notice that `and` and `or` are special forms, not procedures, because the subexpressions are not necessarily all evaluated. `Not` is an ordinary procedure. 